# MVCC 多版本并发控制

## 隔离级别

### 未提交读 -- 脏读
### 已提交读 -- 不可重复读
### 可重复读 -- 幻读
### 可串行化

> Mysql 隔离级别默认为**可重复读**

## MVCC 思路

通过保存数据在某个时间的快照，实现读写并发.

并发控制的一种方法，不同存储引擎的 MVCC 实现是不同的，典型的有乐观并发控制和悲观并发控制.

Mysql InnoDB MVCC 通过乐观并发实现. 其每行数据都有两隐藏列：

* 创建版本号（cv）：创建数据时，使用当前系统版本号作为创建版本号。注意：数据库中的一行数据是有多个版本的
* 删除版本号(dv)：删除数据时，使用当前系统版本号作为删除版本号

> 系统版本号：一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
> 事务版本号：事务开始时的系统版本号。

### SELECT

读取规则：cv <= 当前事务版本号 && （dv == null || dv > 当前事务版本号）

### INSERT

创建数据时，使用当前系统版本号作为创建版本号

### UPDATE

插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行，实际上这里的更新是通过 delete 和 insert 实现的

### DELETE

删除时将当前的系统版本号赋值给删除版本号字段，标识该行数据在那一个事务中会被删除，即使实际上在位commit时该数据没有被删除。根据select的规则后开启懂数据也不会查询到该数据


## MYSQL MVCC 解决了幻读？

从上面的定义可以推断出 “MYSQL MVCC 解决了幻读”。但是仅是针对于单一的 “SELECT” 操作，如 “UPDATE * FROM TAB WHERE xxx” 依然还会存在幻读的现象。
故引出新的概念：

* 快照读。针对 SELECT 操作，会读取快照，即历史版本，遵循 MVCC 的规则
* 当前读。真堵 INSERT,UPDATE,DELETE 操作，会读取当前最新的数据。

## 如何解决幻读

* 串行化隔离级别
* MVCC+next-key locks：next-key locks由record locks(索引加锁) 和 gap locks(间隙锁，每次锁住的不光是需要使用的数据，还会锁住这些数据附近的数据)


## link

* [MySQL的可重复读级别能解决幻读吗](https://www.cnblogs.com/liyus/p/10556563.html)








